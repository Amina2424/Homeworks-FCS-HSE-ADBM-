#!/usr/bin/env python3

"""
Домашняя работа №3 - Алгоритм Нидлмана-Вунша
Автор: Иманалиева Аминат, мАДБМ-251
"""

'''
# 1. Объясните, чему будет равно значение в ячейке (1, 2). Почему? Параметры: Match = +2 Mismatch = -1 Gap = -1

мы выбираем максимальное число из трех вариантов на каждом элементе:

score(i,j) = max(
    score(i-1,j-1) + (Match если символы совпадают, иначе Mismatch),
    score(i-1,j) + Gap,
    score(i,j-1) + Gap,)

ну из-за того что мы стоим на 2 строке 3 столбце, у нас есть три пути прохождения. зависит от макс скора в этой ячейке

'''

import numpy as np

# Создание матрицы 5x5 с числами от 1 до 25
matrix = np.arange(1, 26).reshape(5, 5)
print("Исходная матрица:")
print(matrix)

# Задание 3: Элемент сверху для каждой ячейки. напишите код, который для каждой  ячейки матрицы выведет элемент,находящийся непосредственно над ней (сверху).
# Начинайте с элемента (1,1) и двигайтесь последовательно по строкам, пропуская элементы в нулевой строке и в нулевом столбце

for i in range(1, len(matrix)):
    for j in range(1, len(matrix[i])):
        current_value = matrix[i][j]
        top_value = matrix[i-1][j]  # элемент сверху

        print(f" ({i},{j}) = {current_value},  cверху: {top_value}")


# Задание 2: Элемент по диагонали (левый верхний) для каждой ячейки

# Задача: Напишите код, который для каждой ячейки матрицы выведет элемент, находящийся по диагонали слева сверху.
# Начинайте с элемента (1,1)

for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        current_value = matrix[i][j]

        if i > 0 and j > 0:
            diagonal_value = matrix[i-1][j-1]
            print(f" ({i+1},{j+1}) = {current_value:2}, diag : {diagonal_value}")
        elif i == 0 and j == 0:
            print(f" ({i+1},{j+1}) = {current_value:2}, первая ячейка")
        elif i == 0:
            print(f" ({i+1},{j+1}) = {current_value:2}, нет элемента сверху")
        else:  # j == 0
            print(f" ({i+1},{j+1}) = {current_value:2}, нет элемента слева")


# Задание 3: Элемент слева для каждой ячейки

# Задача: Напишите код, который для каждой  ячейки матрицы выведет элемент, находящийся непосредственно слева.Начинайте с элемента (1,1)


for i in range(1, len(matrix)):
    for j in range(1, len(matrix[i])):
        current_value = matrix[i][j]
        top_value = matrix[i][j-1]
        print(f" ({i},{j}) = {current_value},  слева: {top_value}")



# 1. NumPy: создайте матрицу от 1 до 9

matrix = np.arange(1,10).reshape(3,3)
print(matrix)

# 2. NumPy: соaздайте матрицу от 9 до 1
matrix_2 = np.arange(9,0,-1).reshape(3,3)
print(matrix_2)

# 3. NumPy: транспонируйте матрицу
print('transpose:', np.transpose(matrix))

# 4. NumPy: создайте 2 матрицы и сложите их
A  = np.arange(1,9).reshape(2,4)
B  = np.arange(10,18).reshape(2,4)
print(A+B)


# 5. NumPy: создайте 2 матрицы и перемножьте их
# можем если совпадают внутренние размеры
K = np.arange(1,9).reshape(4,2)
print(np.dot(A,K))

# 6. Используя NumPy создайте единичную матрицу (по главной диагонали единицы)

print(np.eye(3))

'''

# 1. Вам представлен код с реализацией алгоритма Нидлмана-Вунша. Функция needleman_wunsch принимает параметры: match=2, mismatch=-1, gap=-1
# поэксперементируйте с параметрами и посморите, как меняется выравнивание и score. Какие выводы можно сделать?

Я привела оставила пример трех разных вариаций, но в целом можно сказать, что:  

1. При слишком высокой оценке mathc, увеличивается общий score, но выравнивание не меняется
2. Если gap  слишком низкое относительно mismatch, алгоритм будет предпочитать вставлять gaps вместо принятия mismatches, и тогда наша последовательность по выравниванию полупустая (забита гэпами)
3. Если gap слишком высокий, то алгоритм предпочитает принять mismatches, чем создавать много пропусков

Вывод: и тогда мы видим, что относительные значения важнее абсолютных - имеет значение соотношение между match, mismatch и gap.
'''

# 2. Используя numpy создайте матрицу 7 на 7

print(np.arange(1,50).reshape(7,7))

# 3. NumPy: создайтие диагональную матрицу, где по главной диагонали идут числа от 1 до 5

print(np.diag(range(1,6)))

# 4. Напиши функцию, которая принимает матрицу и проверяет, является ли она единичной. В ответе возвращается True или False

def check_matrix(matrix):
    n = len(matrix)

    for i in range(n):
        for j in range(n):
            if i == j:
                if matrix[i][j] != 1:
                    return False
            else:
                if matrix[i][j] != 0:
                    return False

    return True

ex1 = np.diag(range(1,6))
ex2 = np.arange(1,50).reshape(7,7)
ex3 = np.eye(5)

print(check_matrix(ex3), check_matrix(ex2))